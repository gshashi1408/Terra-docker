@Library(['thor-shared-pipelines', 'sift-shared-library']) _

pullRequestBuild = env.CHANGE_TARGET ? true : false;

def buildArtifactName() {
  def artifactBaseName = env.ARTIFACT_NAME
  def branchName = env.GIT_BRANCH.replaceAll('origin/', '')
  def gitCommitHash = env.GIT_COMMIT_HASH
  def artifactName

  if (branchName == 'china') {
      artifactName = "${artifactBaseName}:${env.GIT_TAG}-${gitCommitHash}-${currentBuild.number}"
  } else {
      // Replace any characters not allowed in filenames with underscores
      def safeBranchName = branchName.replaceAll('[^A-Za-z0-9_-]', '_').toLowerCase()
      artifactName = "${artifactBaseName}:${safeBranchName}"
  }

  return artifactName
}

pipeline {
  agent {
    label 'base'
  }

  options {
    buildDiscarder(
      logRotator (
        numToKeepStr: '10'
      )
    )
    instanceType('t3.xlarge')
    instanceExecutors('1')
    disableConcurrentBuilds()
    timestamps()
  }

  environment {
    CLJ_BINARY_URL = 'https://github.com/clj-holmes/clj-holmes/releases/latest/download/clj-holmes-ubuntu-latest'
    SCANNER_HOME = tool 'sonar-scanner'
    SECRET_SONARQUBE_TOKEN = credentials('cdaas-sonar-bot')
    // Used for sending Private Webex notification if the SonarQube Quality Gate fails
    GIT_COMMITTER_EMAIL = sh(script: "git --no-pager show -s --format='%ae' $GIT_COMMIT", returnStdout: true).trim()
    GIT_GENERIC_CREDS = 'sift-reporting-gen-github'
    BRANCH_NAME = env.GIT_BRANCH.replaceAll('origin/', '')
    AWS_ACC_PROD = '563853376529'
    AWS_ACC_STAGE = '072824598875'
    AWS_ROLE = 'jenkins-sift-cdaas'
    AWS_REGION = 'us-west-2'
    AWS_ECR_REPO = "dkr.ecr.${env.AWS_REGION}.amazonaws.com"
    ARTIFACT_NAME = 'china/orlok'
    CORONA_GEN_USER = credentials('corona-cec-user')
    CORONA_GEN_TOKEN = credentials('corona-cec-token')
    CORONA_PRODUCT_ID = '12848'
    CORONA_CSDL_ID = '243005'
    CORONA_ENGINEERING_CONTACT = 'opendns-eng.sift@cisco.com'
    CORONA_RELEASE_NAME = '1.1'
    WEBEX_ROOM_ID = credentials('orlok-govcloud-webex-room-id')
    WEBEX_BOT_TOKEN = 'sift-jenkins-webex-bot-token'
    PUSH_DIRECTLY_TO_CHINA = true
    CHINA_DEV_CRED_ID = 'cicdbotuser-china-dev-creds'
    CHINA_DEV_IAM_ROLE = 'arn:aws-cn:iam::114040874283:role/CICDBotRole'
    CHINA_AWS_ACC_DEV = '114040874283'
    CHINA_DEV_ECR  = '114040874283.dkr.ecr.cn-northwest-1.amazonaws.com.cn'
    CHINA_AWS_REGION = 'cn-northwest-1'
    CHINA_PROD_CRED_ID = 'cicdbotuser-china-prod-creds'
    CHINA_PROD_IAM_ROLE = 'arn:aws-cn:iam::146618076670:role/CICDBotRole'
    CHINA_AWS_ACC_PROD = '146618076670'
    CHINA_PROD_ECR = '146618076670.dkr.ecr.cn-northwest-1.amazonaws.com.cn'
  }

  stages {
    stage('Clean workspace') {
      steps {
        cleanWs()
      }
    }

    stage('Checkout repo code with tags') {
      steps {
        script {
          def scmVars = checkout([
            $class: 'GitSCM',
            branches: scm.branches,
            doGenerateSubmoduleConfigurations: scm.doGenerateSubmoduleConfigurations,
            extensions: [[$class: 'CloneOption', noTags: false, reference: '', shallow: false]],
            userRemoteConfigs: scm.userRemoteConfigs
          ])
          env.GIT_COMMIT_HASH = scmVars.GIT_COMMIT.substring(0,8)
          echo "GIT_COMMIT_HASH: ${GIT_COMMIT_HASH}"
          env.GIT_TAG = sh(script: 'git describe --tags --abbrev=0', returnStdout: true).trim()
          if (env.BRANCH_NAME == 'china') {
            currentBuild.displayName = "${env.GIT_TAG}_${currentBuild.number}"
          } else {
            currentBuild.displayName = "${env.GIT_TAG}_${env.BRANCH_NAME}_${GIT_COMMIT_HASH}_${currentBuild.number}"
          }
        }
      }
    }

    // Will unmute below once the issues with Tests stage will be resolved
    // stage('Tests - docker-compose') {
    //   steps {
    //     withAWS(
    //       roleAccount: env.AWS_ACC_PROD, 
    //       role: env.AWS_ROLE,
    //       region: env.AWS_REGION
    //     ) {
    //       script {
    //         withChecks('Tests - Docker-compose') {
    //           def exitCode = sh(script: """#!/usr/bin/env bash
    //             set -e
    //             echo '========================================='
    //             echo "Setting credentials for profile 'default'"
    //             echo '^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^'
    //             aws configure set aws_access_key_id "\$AWS_ACCESS_KEY_ID" --profile default
    //             aws configure set aws_secret_access_key "\$AWS_SECRET_ACCESS_KEY" --profile default
    //             aws configure set aws_session_token "\$AWS_SESSION_TOKEN" --profile default
    //             aws configure set s3.signature_version s3v4

    //             echo "Let's see who we are:"
    //             aws sts get-caller-identity
                
    //             echo "Logging into AWS ECR...üîê"
    //             aws ecr get-login-password --region "\$AWS_REGION" | docker login -u AWS --password-stdin https://${env.AWS_ACC_PROD}.dkr.ecr.us-west-2.amazonaws.com/

    //             # start containers
    //             docker-compose up --build --exit-code-from orlok
    //             # stop and remove containers
    //             docker-compose rm -f -s
    //             # remove volumes
    //             docker volume rm \$(docker volume ls -q)
    //           """, returnStdout: true)
    //           if (exitCode == 0) {
    //             publishChecks([name: 'Tests - Docker-compose', title: 'Passed successfully!'])
    //           } else {
    //             publishChecks([name: 'Tests - Docker-compose', title: 'Tests stage Failed!', summary: "Exit code: ${exitCode}", conclusion: 'FAILURE'])
    //             error "Tests stage Failed!"
    //           }
    //         }
    //       }
    //     }
    //   }
    // }

    stage('Static Analysis') {
      steps {
        withCredentials(
          [usernamePassword(
            credentialsId: env.GIT_GENERIC_CREDS,
            usernameVariable: 'USER',
            passwordVariable: 'PAT_TOKEN'
          )]
        ) {
          sh """#!/usr/bin/env bash
          set -e
          echo "Downloading Clj-Holmes!..üì•"
          curl -sS -L ${env.CLJ_BINARY_URL} -o ./clj-holmes
          chmod +x clj-holmes
          echo "Fetching Clj-Holmes rules!..üì•"
          ./clj-holmes fetch-rules
          echo "Performing Clj-Holmes scan!..üîé"
          ./clj-holmes scan -p . --no-verbose --output-type stdout
          echo "Recording clj-holmes scan results!..üíæ"
          rm -rf security_scan_results/*
          ./clj-holmes scan -p . --no-verbose --output-type json --output-file security_scan_results/clj_holmes_scan_results-${env.GIT_COMMIT_HASH}.json
          ls -la security_scan_results/
          echo 'Configuring git credentials...üõ†Ô∏è'
          git config --global user.email "$USER@cisco.com"
          git config --global user.name "$USER"
          git config credential.helper \\
            '!f() { echo username=$USER; echo "password=$PAT_TOKEN"; };f'
          git add security_scan_results/*
          git commit -m "clj-holmes scanning result"
          """
        }
        script {
          withSonarQubeEnv('cdaas-sonar-prod') {
            sh """#!/usr/bin/env bash
            ${SCANNER_HOME}/bin/sonar-scanner \\
              -Dsonar.login=${SECRET_SONARQUBE_TOKEN} \\
              -Dsonar.projectVersion=\$(git describe --tags --abbrev=0) \\
              -Dsonar.branch.name=${env.BRANCH_NAME} \\
              -Dproject.settings=sonar-project.properties \\
            """
          }
          timeout(time: 5, unit: 'MINUTES') {
            def qualitygate = waitForQualityGate()
            currentBuild.description = "Quality Gate ${qualitygate.status}"
            if (qualitygate.status != "OK") {
              if (BRANCH_NAME != 'master') {
                unstable "Quality Gate ${qualitygate.status}. Please, address new issues"
              }
              postWebex(credentialsId: WEBEX_BOT_TOKEN,
                recipientType: 'toPersonEmail',
                recipientId: "${GIT_COMMITTER_EMAIL}",
                message: """<strong>brain-dead build: ${currentBuild.currentResult}. Quality Gate: ${qualitygate.status}. Please, address new issues (<a href=\'$JOB_URL\'>$JOB_NAME</a>)</strong>"""
              )
            }
          }
        }
      }
    }

    stage('Release Tag') {
      when {
        branch 'china'
      }
      steps {
        withCredentials(
          [usernamePassword(
            credentialsId: env.GIT_GENERIC_CREDS,
            usernameVariable: 'USER',
            passwordVariable: 'PAT_TOKEN'
            )
          ]
        ) {
          sh """#!/usr/bin/env bash
            set -e
            SECSLEEP=10

            echo 'Configuring git credentials...üõ†Ô∏è'
            git config user.email "${USER}@cisco.com"
            git config user.name "${USER}"
            git config credential.helper \\
              '!f() { echo username=${USER}; echo "password=${PAT_TOKEN}"; };f'

            echo "=============================="
            echo "Current branch: ${env.BRANCH_NAME}"
            echo "=============================="
            NEWTAG=\$(git tag | ./ci/compute_release_tag.py)
            echo "NEW release tag will be: \$NEWTAG"
            echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
            echo "Sleeping \$SECSLEEP seconds... last chance to abort"
            sleep \$SECSLEEP

            echo " "
            git tag \$NEWTAG
            git push origin \$NEWTAG
            echo " "
            if [ \$? -eq 0 ]; then
              echo "‚úÖ OK - version \$NEWTAG tagged and pushed to Github";
            else
              echo "‚ùå FAIL - Failed to push version \$NEWTAG to Github";
            fi
          """
        }
      }
    }

    stage('Build JAR and Docker image') {
      steps {
        script {
          withChecks('Docker - Build') {
            withAWS(
              roleAccount: env.AWS_ACC_PROD, 
              role: env.AWS_ROLE,
              region: env.AWS_REGION
            ) {
              artifactName = buildArtifactName()
              def exitCode = sh(script: """#!/usr/bin/env bash
                set -e
                echo "Let's see who we are:"
                aws sts get-caller-identity

                echo "Setting credentials for profile 'default'"
                aws configure set aws_access_key_id "\$AWS_ACCESS_KEY_ID" --profile default
                aws configure set aws_secret_access_key "\$AWS_SECRET_ACCESS_KEY" --profile default
                aws configure set aws_session_token "\$AWS_SESSION_TOKEN" --profile default
                aws configure set s3.signature_version s3v4

                echo "======================="
                echo "Fetching Leiningen!..üì•"
                echo "^^^^^^^^^^^^^^^^^^^^^^^"
                curl -sS -O -L "https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein"
                chmod +x lein

                aws ecr get-login-password --region "\$AWS_REGION" | docker login -u AWS --password-stdin https://${AWS_ACC_PROD}.dkr.ecr.us-west-2.amazonaws.com/

                echo "===================="
                echo "Copying JARs from S3"
                echo "^^^^^^^^^^^^^^^^^^^^"
                aws s3 cp s3://avc-reporting/REPORTING.json ./REPORTING.json --only-show-errors &
                aws s3 cp s3://cdfw-application-category-artifacts-production/cdfw_apps_categories.json ./cdfw_apps_categories.json --only-show-errors &
                aws s3 cp s3://cdfw-application-category-artifacts-production/casi-app-category-mapping.json ./casi-app-category-mapping.json --only-show-errors &
                aws s3 cp s3://casi-mapping-prod/casi_nbar_openappid_mapping.csv ./casi_nbar_openappid_mapping.csv --only-show-errors &
                aws s3 cp s3://ipsconfig-internal-artifacts-prod-us-west-2/ntd_db_slim.zip ./ntd_db_slim.zip --only-show-errors &
                aws s3 cp s3://sift-files/threat-definitions/latest/threat-descriptions.json ./threat-descriptions.json --only-show-errors &
                
                wait

                echo "============================="
                echo "Starting Leiningen build!..üõ†Ô∏è"
                echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                ./lein uberjar

                echo "Starting docker build!..üöß"
                docker build -f Dockerfile.k8s \\
                  --no-cache --build-arg orlok_config_file_name=orlok-kubernetes-template.edn \\
                  -t ${artifactName} .
              """, returnStatus: true)
              if (exitCode == 0) {
                publishChecks([name: 'Docker - Build', title: 'Passed successfully!'])
              } else {
                publishChecks([name: 'Docker - Build', title: 'Docker build stage Failed!', summary: "Exit code: ${exitCode}", conclusion: 'FAILURE'])
                error "Docker build!"
              }
            }
          }
        }
      }
    }

    stage('Upload to Corona') {
      when {
        branch 'china'
      }
      steps {
        script {
          withChecks('Corona - Upload') {
            SendToCorona(
              username: env.CORONA_GEN_USER,
              password: env.CORONA_GEN_TOKEN,
              productId: env.CORONA_PRODUCT_ID,
              csdlIdentifier: env.CORONA_CSDL_ID,
              engineeringContact: env.CORONA_ENGINEERING_CONTACT,
              image: "${artifactName}",
              imageType: 'docker',
              releaseName: env.CORONA_RELEASE_NAME
            )            
          }
        }
      }
    }

    stage('Tag and push to Commercial staging ECR') {
      when{
          environment name: 'PUSH_DIRECTLY_TO_CHINA', value: 'false'
      }
      steps {
        script {
          withChecks('Docker upload - Staging ECR') {
            withAWS(
              roleAccount: env.AWS_ACC_STAGE, 
              role: env.AWS_ROLE,
              region: env.AWS_REGION
            ) {
              echo "Artifact name: ${artifactName}"
              def exitCode = sh(script: """#!/usr/bin/env bash
                set -e
                echo "==========================="
                echo "Uploading Docker image!..üì§"
                echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                aws ecr get-login-password --region us-west-2 | docker login -u AWS --password-stdin https://${env.AWS_ACC_STAGE}.dkr.ecr.us-west-2.amazonaws.com/
                docker tag ${artifactName} ${env.AWS_ACC_STAGE}.dkr.ecr.us-west-2.amazonaws.com/${artifactName}
                docker push ${env.AWS_ACC_STAGE}.dkr.ecr.us-west-2.amazonaws.com/${artifactName}
              """, returnStatus: true)
              if (exitCode == 0) {
                publishChecks([name: 'Docker upload - Staging ECR', title: 'Passed successfully!'])
              } else {
                publishChecks([name: 'Docker upload - Staging ECR', title: 'Docker upload to Staging ECR Failed!', summary: "Exit code: ${exitCode}", conclusion: 'FAILURE'])
                error "Docker upload to Staging ECR Failed!"
              }
            }
          }
        }
      }
    }

    stage('Tag and push to china dev ECR') {
      when{
          environment name: 'PUSH_DIRECTLY_TO_CHINA', value: 'true'
      }
      steps {
        script {
          withChecks('Docker upload - China dev ECR') {
            withAWS(
              credentials: env.CHINA_DEV_CRED_ID,
              roleAccount: env.CHINA_AWS_ACC_DEV, 
              role: env.CHINA_DEV_IAM_ROLE,
              region: env.CHINA_AWS_REGION
            ) {
              echo "Artifact name: ${artifactName}"
              def exitCode = sh(script: """#!/usr/bin/env bash
                set -e
                echo "==========================="
                echo "Uploading Docker image!..üì§"
                echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                aws ecr get-login-password --region ${env.CHINA_AWS_REGION} | docker login -u AWS --password-stdin https://${env.CHINA_DEV_ECR}/
                docker tag ${artifactName} ${env.CHINA_DEV_ECR}/${artifactName}
                docker push ${env.CHINA_DEV_ECR}/${artifactName}
              """, returnStatus: true)
              if (exitCode == 0) {
                publishChecks([name: 'Docker upload - China dev ECR', title: 'Passed successfully!'])
              } else {
                publishChecks([name: 'Docker upload - China dev ECR', title: 'Docker upload to China dev ECR Failed!', summary: "Exit code: ${exitCode}", conclusion: 'FAILURE'])
                error "Docker upload to China dev ECR Failed!"
              }
            }
          }
        }
      }
    }

    stage('Tag and push to Prod ECR') {
      when {
        allOf {
          branch 'china'
          environment name: 'PUSH_DIRECTLY_TO_CHINA', value: 'false'
        }
      }
      steps {
        script {
          withChecks('Docker upload - Prod ECR') {
            withAWS(
              roleAccount: env.AWS_ACC_PROD, 
              role: env.AWS_ROLE,
              region: env.AWS_REGION
            ) {
              echo "Artifact name: ${artifactName}"
              def exitCode = sh(script: """#!/usr/bin/env bash
                set -e
                echo "==========================="
                echo "Uploading Docker image!..üì§"
                echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                aws ecr get-login-password --region us-west-2 | docker login -u AWS --password-stdin https://${env.AWS_ACC_PROD}.dkr.ecr.us-west-2.amazonaws.com/
                docker tag ${artifactName} ${env.AWS_ACC_PROD}.dkr.ecr.us-west-2.amazonaws.com/${artifactName}
                docker push ${env.AWS_ACC_PROD}.dkr.ecr.us-west-2.amazonaws.com/${artifactName}
              """, returnStatus: true)
              if (exitCode == 0) {
                publishChecks([name: 'Docker upload - Prod ECR', title: 'Passed successfully!'])
              } else {
                publishChecks([name: 'Docker upload - Prod ECR', title: 'Docker upload to Prod ECR Failed!', summary: "Exit code: ${exitCode}", conclusion: 'FAILURE'])
                error "Docker upload to Prod ECR Failed!"
              }
            }
          }
        }
      }
    }

    stage('Tag and push to china prod ECR') {
      when{
          allOf {
            branch 'china'
            environment name: 'PUSH_DIRECTLY_TO_CHINA', value: 'true'
        }
      }
      steps {
        script {
          withChecks('Docker upload - China prod ECR') {
            withAWS(
              credentials: env.CHINA_PROD_CRED_ID,
              roleAccount: env.CHINA_AWS_ACC_PROD, 
              role: env.CHINA_PROD_IAM_ROLE,
              region: env.CHINA_AWS_REGION
            ) {
              echo "Artifact name: ${artifactName}"
              def exitCode = sh(script: """#!/usr/bin/env bash
                set -e
                echo "==========================="
                echo "Uploading Docker image!..üì§"
                echo "^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                aws ecr get-login-password --region ${env.CHINA_AWS_REGION} | docker login -u AWS --password-stdin https://${env.CHINA_PROD_ECR}/
                docker tag ${artifactName} ${env.CHINA_PROD_ECR}/${artifactName}
                docker push ${env.CHINA_PROD_ECR}/${artifactName}
              """, returnStatus: true)
              if (exitCode == 0) {
                publishChecks([name: 'Docker upload - China dev ECR', title: 'Passed successfully!'])
              } else {
                publishChecks([name: 'Docker upload - China dev ECR', title: 'Docker upload to China dev ECR Failed!', summary: "Exit code: ${exitCode}", conclusion: 'FAILURE'])
                error "Docker upload to China dev ECR Failed!"
              }
            }
          }
        }
      }
    }

  }

  post {
    success {
      script {
        if (pullRequestBuild) {
          messageTitle = "### $env.JOB_NAME - PR Build Finished ‚úÖ üëç\\n**Title:** $env.CHANGE_TITLE\\n**Author:** $env.CHANGE_AUTHOR_EMAIL"
        } else {
          messageTitle = "### $env.JOB_NAME - Build Finished ‚úÖ üëç"
        }
        sendWebexMessage(credentialsId: env.WEBEX_BOT_TOKEN,
          recipientType: 'roomId',
          recipientId: env.WEBEX_ROOM_ID,
          message: "$messageTitle\\n"+
                  "**Build URL:** [$env.JOB_NAME#$env.BUILD_NUMBER]($env.BUILD_URL)\\n"+
                  "**Branch:** $env.BRANCH_NAME\\n"+
                  "**Status:** SUCCESS"
        )
      }
    }

    failure {
      script {
        if (pullRequestBuild) {
          messageTitle = "### $env.JOB_NAME - PR Build Failed ‚ùå üëé\\n**Title:** $env.CHANGE_TITLE\\n**Author:** $env.CHANGE_AUTHOR_EMAIL"
        } else {
          messageTitle = "### $env.JOB_NAME - Build Finished ‚ùå üëé"
        }
        sendWebexMessage(credentialsId: env.WEBEX_BOT_TOKEN,
          recipientType: 'roomId',
          recipientId: env.WEBEX_ROOM_ID,
          message: "$messageTitle\\n"+
                  "**Build URL:** [$env.JOB_NAME#$env.BUILD_NUMBER]($env.BUILD_URL)\\n"+
                  "**Branch:** $env.BRANCH_NAME\\n"+
                  "**Status:** FAILURE"
        )
      }
    }

    cleanup {
      script {
        sh 'docker system prune -f'
      }
      cleanWs()
    }
  }
}
